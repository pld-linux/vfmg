#!/usr/bin/perl -w

use strict;
use File::Find;

# get locale (for Name[*])

my $lang4="";
$lang4=$ENV{LANG} if exists $ENV{LANG};
$lang4=$ENV{LC_MESSAGES} if exists $ENV{LC_MESSAGES};
$lang4=$ENV{LC_ALL} if exists $ENV{LC_ALL};
my $lang3=$lang4;
$lang3=~s/@.*//;
my $lang2=$lang3;
$lang2=~s/\..*//;
my $lang1=$lang2;
$lang1=~s/_.*//;

# read desktop entries TODO: DESKTOP_FILE_PATH

my %apps;
	my $ae=1;	# application exec
	my $ai=2;	# application icon
find(\&wanted,'/usr/share/applications/');

sub wanted {
	return if (!-f || /^\./ || !/\.desktop$/);
	my $name="";
	my $exec="";
	my $icon="";
	my $cats="";
	my $term=0;
	my $lang=0;
	open F_IN, "$_" or warn "! Cannot open $_: $!\n" and return;
	while(<F_IN>) {
		if (/^Name=(.+)/ && $lang<1) {
			$name=$1;
		}
		if (/^Name\[$lang1\]=(.+)/ && $lang<2) {
			$name=$1;
			$lang=1;
		}
		if (/^Name\[$lang2\]=(.+)/ && $lang<3) {
			$name=$1;
			$lang=2;
		}
		if (/^Name=\[$lang3\](.+)/ && $lang<4) {
			$name=$1;
			$lang=3;
		}
		if (/^Name=\[$lang4\](.+)/ && $lang<5) {
			$name=$1;
			$lang=4;
		}
		$icon=$1 if /^Icon=(.+)/;
		$exec=$1 if /^Exec=(.+)/;
		$cats=$1 if /^Categories=(.+)/;
		$term=1 if /^Terminal=1/;
	}
	close F_IN;
	$exec="xterm -e $exec" if $term==1;
	my @cats=split(/;+/,$cats);
	my $cat;
	foreach $cat(@cats) {
# TODO: check if binary exist within $PATH
		$apps{$cat}{$name}[$ae]="$exec";
# TODO: check if icon exist
		$apps{$cat}{$name}[$ai]="$icon";
	}
}

=for comment print apps
foreach my $category(sort keys %apps) {
	print "$category	\n";
	foreach my $name(sort keys %{$apps{$category}}) {
		printf "	%s|%s|%s\n",$name,$apps{$category}{$name}[$ai],$apps{$category}{$name}[$ae];
	}
	print "\n";
}
=cut

# read XDG menu specification

my $file="";

#open F_IN, "/etc/xdg/menus/applications.menu" or die "! Cannot open $_: $!\n";
open F_IN, "/home/gotar/xdg/menus/applications.menu" or die "! Cannot open $_: $!\n";
#open F_IN, "/home/gotar/xdg/menus/kde-settings.menu" or die "! Cannot open $_: $!\n";
while(<F_IN>) {
	#s/\s*//g;
	chop;
	$file.=$_;
}
close F_IN;

sub gettag {
	$file=~s/.*?<(.*?)>\s*//;
	$1;
}

sub getname {
	$file=~s/\s*(.*?)\s*<//;
	$file="<".$file;
	$1;
}

my @menu;
		# positive level: submenu
		# negative level: entry
		my $ml=0;
		my $mi=1;
		my $me=2;
=for menustruct
	menu[x] {ble}	-1	ble.png	/usr/bin/ble
		{bla}	3	bla.xpm
		{foo}	5	foo.png
		{bar}	7	bar.xpm

test example:

$menu[0]{zadad}[0]=-1;
$menu[0]{zadad}[1]="foobar.png";
$menu[0]{zadad}[2]="/foo/bar/tralala";
$menu[0]{dad}[0]=1;
$menu[0]{dad}[1]="bar.png";
$menu[1]{dcd}[0]=-1;
$menu[1]{dcd}[1]="foo.png";
$menu[1]{dcd}[2]="/foo/tralala";
=cut

my $level=0;
my $mno=0;	# menu number
my $trigger=0;
my $tag;
my $name;
my $dir;
my @directory;
	my $dn=0;	# directory name
	my $di=1;	# directory icon
my $include;
my %tmpapps;
my @menustack;

sub cand {
	my %iapps;	# internal applications list
	foreach my $dir (keys %apps) {
	foreach my $name(sort keys %{$apps{$dir}}) {
		$iapps{$dir}{$name}[$ai]=$apps{$dir}{$name}[$ai];
		$iapps{$dir}{$name}[$ae]=$apps{$dir}{$name}[$ae];
	}
	}
	while (1) {
		$tag=&gettag;
		last if($tag=~/^\/and$/i);
		if($tag=~/^category$/i) {
			$dir=&getname;
			foreach my $cat (keys %iapps) {
			foreach my $name(keys %{$iapps{$cat}}) {
				delete($iapps{$cat}{$name}) unless exists $iapps{$dir}{$name};
			}
			}
			&gettag;	# must be </category> else GIGO and we don't care
			next;
		}
		if($tag=~/^(and|or|not)$/i) {
			my %tmpapps;
			%tmpapps=&cand if $tag=~/^and$/i;
			%tmpapps=&cor if $tag=~/^or$/i;
#			%tmpapps=&cnot if $tag=~/^not$/i;
			foreach my $cat (keys %iapps) {
			foreach my $name(keys %{$iapps{$cat}}) {
				delete($iapps{$cat}{$name}) unless exists $tmpapps{$cat}{$name};
			}
			}
			next;
		}
	}
	%iapps;
}

sub cor {
	my %iapps;	# internal applications list
	while (1) {
		$tag=&gettag;
		last if($tag=~/^\/or$/i);
		if($tag=~/^category$/i) {
			$dir=&getname;
			foreach my $name(keys %{$apps{$dir}}) {
				$iapps{$dir}{$name}[$ai]=$apps{$dir}{$name}[$ai];
				$iapps{$dir}{$name}[$ae]=$apps{$dir}{$name}[$ae];
			}
			next;
		}
		if($tag=~/^(and|or|not)$/i) {
			my %tmpapps;
			%tmpapps=&cand if $tag=~/^and$/i;
			%tmpapps=&cor if $tag=~/^or$/i;
			%tmpapps=&cnot if $tag=~/^not$/i;
			foreach my $cat (keys %tmpapps) {
			foreach my $name(keys %{$tmpapps{$cat}}) {
				$iapps{$cat}{$name}[$ai]=$tmpapps{$cat}{$name}[$ai];
				$iapps{$cat}{$name}[$ae]=$tmpapps{$cat}{$name}[$ae];
			}
			}
			next;
		}
	}
	%iapps;
}

sub cnot {
	$tag=&gettag;
}

$#menu++;	# let's start from index 1
		# this index is a pointer to menu struct
		# (entry in $menu[] table) via $mno
		# 0 means empty, so it's ommited
		# twill be made choosable

while($trigger==0 || $level>0) {
	$tag=&gettag;
	if($tag=~/^menu$/i) {
		$level++;
		$#menu++;
		$menustack[$#menustack+1]=$mno;
		$mno=$#menu;
		$name="";
		$include=0;
		$trigger=1;
		next;
	}
	if($tag=~/^\/menu$/i) {
		#for(my $i=0; $i<=$#menu; $i++) {
		my $i=$menustack[$#menustack];
		if(exists $directory[$level]) {
			foreach my $entry(keys %{$menu[$i]}) {
				delete($menu[$i]{$entry}) if $menu[$i]{$entry}[$ml]==$mno;
			}
			$menu[$i]{$directory[$level][$dn]}[$ml]=$mno;
			$menu[$i]{$directory[$level][$dn]}[$mi]=$directory[$level][$di];
			delete($directory[$level]);
		}
		#}
		$mno=$i;
		$#menustack--;
		$level--;
		next;
	}
	if($tag=~/^name$/i) {
		$name=&getname;
		$menu[$menustack[$#menustack]]{$name}[$ml]=$mno;
		&gettag;	# must be </name> else GIGO and we don't care
		next;
	}
	if($tag=~/^directory$/i) {
		$dir=&getname;
		my $lang=0;
		my $name="";
		my $icon="";
		open F_IN, "/usr/share/desktop-directories/$dir" or warn "! No desktop-directory file for $dir: $!\n";
	while(<F_IN>) {
		if (/^Name=(.+)/ && $lang<1) {
			$name=$1;
		}
		if (/^Name\[$lang1\]=(.+)/ && $lang<2) {
			$name=$1;
			$lang=1;
		}
		if (/^Name\[$lang2\]=(.+)/ && $lang<3) {
			$name=$1;
			$lang=2;
		}
		if (/^Name=\[$lang3\](.+)/ && $lang<4) {
			$name=$1;
			$lang=3;
		}
		if (/^Name=\[$lang4\](.+)/ && $lang<5) {
			$name=$1;
			$lang=4;
		}
		$icon=$1 if /^Icon=(.+)/;
	}
	close F_IN;
		$directory[$level][$dn]=$name;
		$directory[$level][$di]=$icon;
		&gettag;	# must be </directory> else GIGO and we don't care
		next;
	}
	if($tag=~/^include$/i) {
		$include=1;
		next;
	}
	if($tag=~/^\/include$/i) {
		$include=0;
		next;
	}
	if(($tag=~/^(and|or|not)$/i)&& $include) {
		%tmpapps=&cand if $tag=~/^and$/i;
		%tmpapps=&cor if $tag=~/^or$/i;
		%tmpapps=&cnot if $tag=~/^not$/i;
		foreach my $dir (keys %tmpapps) {
		foreach my $name(keys %{$tmpapps{$dir}}) {
			$menu[$mno]{$name}[$ml]=-1;
			$menu[$mno]{$name}[$mi]=$tmpapps{$dir}{$name}[$ai];
			$menu[$mno]{$name}[$me]=$tmpapps{$dir}{$name}[$ae];
		}
		}
		next;
	}
	if(($tag=~/^category$/i)&& $include) {
		$dir=&getname;
		foreach my $name(keys %{$apps{$dir}}) {
			$menu[$mno]{$name}[$ml]=-1;
			$menu[$mno]{$name}[$mi]=$apps{$dir}{$name}[$ai];
			$menu[$mno]{$name}[$me]=$apps{$dir}{$name}[$ae];
		}
		&gettag;	# must be </category> else GIGO and we don't care
		next;
	}
	if($tag=~/^mergefile$/i) {
		$name=&getname;
		&gettag;	# must be </mergefile> else GIGO and we don't care
		my $tmpfile="";
		open F_IN, "/etc/xdg/menus/$name" or warn "! Cannot open $_: $!\n";
		while(<F_IN>) {
			chop;
			$tmpfile.=$_;
		}
		close F_IN;
		$file=$tmpfile.$file;
		next;
	}
	if(($tag=~/^\/(name|directory|and|or|not|category|mergefile)$/i)&& $include) {
		print "warning: XDG file corrupted!\n";
	}
	# print "$level: $tag\n";
}

# print "\n\n\n$file\n";

$level=-1;
sub outgen {
	my $no=$_[0];
	foreach my $entry(sort keys %{$menu[$no]}) {
		next if $menu[$no]{$entry}[$ml]==0;
		if($menu[$no]{$entry}[$ml]<0) {
			for(my $i=0; $i<=$level; $i++) {
				print "	";
			}
			print "Entry: \"$entry\" $menu[$no]{$entry}[$mi] $menu[$no]{$entry}[$me]\n";
		} else {
			for(my $i=0; $i<=$level; $i++) {
				print "	";
			}
			print "Menu: \"$entry\" $menu[$no]{$entry}[$mi]\n";
			$level++;
			outgen($menu[$no]{$entry}[$ml]);
			$level--;
		}
	}
}

&outgen(0);
