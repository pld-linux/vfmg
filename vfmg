#!/usr/bin/perl -w

use strict;
use File::Find;
use Getopt::Long;

my $o_help=0;
my $o_tags=0;
my $o_end=0;
my $o_icons=0;
my $o_exec=0;
my @path;

GetOptions('help'=>\$o_help,
	'tags'=>\$o_tags,
	'end|e'=>\$o_end,
	'icons'=>\$o_icons,
	'exec|x'=>\$o_exec
	);

if($o_help) {
	print "Usage:
	-h, --help	- print this help
	-t, --tags	- echo omitted tags to stderr
	-e, --end	- echo omitted XDG file ending to stderr
	-i, --icons	- check for icons existence
	-x, --exec	- check for binaries existence
	";
	exit;
}

if($o_exec) {
	@path=split(/:+/,$ENV{'PATH'});
}

# get locale (for Name[*])

my $lang4="";
$lang4=$ENV{'LANG'} if exists $ENV{'LANG'};
$lang4=$ENV{'LC_MESSAGES'} if exists $ENV{'LC_MESSAGES'};
$lang4=$ENV{'LC_ALL'} if exists $ENV{'LC_ALL'};
my $lang3=$lang4;
$lang3=~s/@.*//;
my $lang2=$lang3;
$lang2=~s/\..*//;
my $lang1=$lang2;
$lang1=~s/_.*//;

# what is $DESKTOP_FILE_PATH?

my %apps;
	my $ae=0;	# application exec
	my $ai=1;	# application icon
find(\&wanted,'/usr/share/applications/');

sub wanted {
	return if (!-f || /^\./ || !/\.desktop$/);
	my $name="";
	my $exec="";
	my $icon="";
	my $cats="";
	my $term=0;
	my $lang=0;
	open F_IN, "$_" or warn "$_: $!\n" and return;
	while(<F_IN>) {
		if (/^Name=(.+)/ && $lang<1) {
			$name=$1;
		}
		if (/^Name\[$lang1\]=(.+)/ && $lang<2) {
			$name=$1;
			$lang=1;
		}
		if (/^Name\[$lang2\]=(.+)/ && $lang<3) {
			$name=$1;
			$lang=2;
		}
		if (/^Name=\[$lang3\](.+)/ && $lang<4) {
			$name=$1;
			$lang=3;
		}
		if (/^Name=\[$lang4\](.+)/ && $lang<5) {
			$name=$1;
			$lang=4;
		}
		$icon=$1 if /^Icon=(.+)/;
		$exec=$1 if /^Exec=(.+)/;
		$cats=$1 if /^Categories=(.+)/;
		$term=1 if /^Terminal=1/;
	}
	close F_IN;
	$exec="xterm -e $exec" if $term;
	my @cats=split(/;+/,$cats);
	if($o_exec) {
		my $exists=0;
		my $bin=$exec;
		$bin=~s/(\S+).*/$1/;
		foreach my $dir(@path) {
			$exists=1 if -x "$dir/$bin";
		}
		@cats=() unless $exists;
	}
	if($o_icons) {
		my $exists=0;
		foreach my $dir("$ENV{'HOME'}/.icons","/usr/share/icons","/usr/share/pixmaps") {
			$exists=1 if((-f "$dir/$icon")||(-f "$dir/$icon.xpm"))
		}
		$icon="" unless $exists;
	}
	foreach my $cat(@cats) {
		#$apps{$cat}{$name}[$ae]="$exec";
		#$apps{$cat}{$name}[$ai]="$icon";
		$apps{$cat}{$name}=[$exec,$icon];
	}
}

=for comment print apps
foreach my $category(sort keys %apps) {
	print "$category	\n";
	foreach my $name(sort keys %{$apps{$category}}) {
		printf "	%s|%s|%s\n",$name,$apps{$category}{$name}[$ai],$apps{$category}{$name}[$ae];
	}
	print "\n";
}
=cut

# read XDG menu specification

my $file="";

open F_IN, "/etc/xdg/menus/applications.menu" or die "/etc/xdg/menus/applications.menu: $!\n";
while(<F_IN>) {
	#s/\s*//g;
	chop;
	$file.=$_;
}
close F_IN;

sub gettag {
	$file=~s/.*?<(.*?)>\s*//;
	$1;
}

sub getname {
	$file=~s/\s*(.*?)\s*<//;
	$file="<".$file;
	$1;
}

my @menu;
	my $ml=0;	# positive level: submenu
			# negative level: entry
	my $mi=1;
	my $me=2;
=for menustruct
	menu[x] {ble}	-1	ble.png	/usr/bin/ble
		{bla}	3	bla.xpm
		{foo}	5	foo.png
		{bar}	7	bar.xpm

test example:

$menu[0]{zadad}[0]=-1;
$menu[0]{zadad}[1]="foobar.png";
$menu[0]{zadad}[2]="/foo/bar/tralala";
$menu[0]{dad}[0]=1;
$menu[0]{dad}[1]="bar.png";
$menu[1]{dcd}[0]=-1;
$menu[1]{dcd}[1]="foo.png";
$menu[1]{dcd}[2]="/foo/tralala";
=cut

my $level=0;
my $mno=0;	# menu number
my $trigger=0;
my $tag;
my $name;
my $dir;
my @directory;
	my $dn=0;	# directory name
	my $di=1;	# directory icon
my $include;
my %tmpapps;
my @menustack;

sub cand {
	my %iapps;	# internal applications list
	foreach my $dir (keys %apps) {
	foreach my $name(keys %{$apps{$dir}}) {
		#$iapps{$dir}{$name}[$ai]=$apps{$dir}{$name}[$ai];
		#$iapps{$dir}{$name}[$ae]=$apps{$dir}{$name}[$ae];
		$iapps{$dir}{$name}=[$apps{$dir}{$name}[$ae],$apps{$dir}{$name}[$ai]];
	}
	}
	while (1) {
		$tag=gettag();
		last if($tag=~/^\/and$/i);
		if($tag=~/^category$/i) {
			$dir=getname();
			foreach my $cat (keys %iapps) {
			foreach my $name(keys %{$iapps{$cat}}) {
				delete($iapps{$cat}{$name}) unless exists $iapps{$dir}{$name};
			}
			}
			gettag();	# must be </category> else GIGO and we don't care
			next;
		}
		if($tag=~/^(and|or|not)$/i) {
			my %tmpapps;
			%tmpapps=cand() if $tag=~/^and$/i;
			%tmpapps=cor() if $tag=~/^or$/i;
			%tmpapps=cnot() if $tag=~/^not$/i;
			foreach my $cat (keys %iapps) {
			foreach my $name(keys %{$iapps{$cat}}) {
				delete($iapps{$cat}{$name}) unless exists $tmpapps{$cat}{$name};
			}
			}
			next;
		}
		warn "warning: possible XDG file corruption!: $tag\n";
	}
	%iapps;
}

sub cor {
	my %iapps;	# internal applications list
	while (1) {
		$tag=gettag();
		last if($tag=~/^\/or$/i);
		if($tag=~/^category$/i) {
			$dir=getname();
			foreach my $name(keys %{$apps{$dir}}) {
				#$iapps{$dir}{$name}[$ai]=$apps{$dir}{$name}[$ai];
				#$iapps{$dir}{$name}[$ae]=$apps{$dir}{$name}[$ae];
				$iapps{$dir}{$name}=[$apps{$dir}{$name}[$ae],$apps{$dir}{$name}[$ai]];
			}
			gettag();	# must be </category> else GIGO and we don't care
			next;
		}
		if($tag=~/^(and|or|not)$/i) {
			my %tmpapps;
			%tmpapps=cand() if $tag=~/^and$/i;
			%tmpapps=cor() if $tag=~/^or$/i;
			%tmpapps=cnot() if $tag=~/^not$/i;
			foreach my $cat (keys %tmpapps) {
			foreach my $name(keys %{$tmpapps{$cat}}) {
				#$iapps{$cat}{$name}[$ai]=$tmpapps{$cat}{$name}[$ai];
				#$iapps{$cat}{$name}[$ae]=$tmpapps{$cat}{$name}[$ae];
				$iapps{$cat}{$name}=[$tmpapps{$cat}{$name}[$ae],$tmpapps{$cat}{$name}[$ai]];
			}
			}
			next;
		}
		warn "warning: possible XDG file corruption!: $tag\n";
	}
	%iapps;
}

sub cnot {
	my %iapps;	# internal applications list
	foreach my $dir (keys %apps) {
	foreach my $name(keys %{$apps{$dir}}) {
		#$iapps{$dir}{$name}[$ai]=$apps{$dir}{$name}[$ai];
		#$iapps{$dir}{$name}[$ae]=$apps{$dir}{$name}[$ae];
		$iapps{$dir}{$name}=[$apps{$dir}{$name}[$ae],$apps{$dir}{$name}[$ai]];
	}
	}
	while (1) {
		$tag=gettag();
		last if($tag=~/^\/not$/i);
		if($tag=~/^category$/i) {
			$dir=getname();
			foreach my $cat (keys %iapps) {
			next if $cat eq $dir;
			foreach my $name(keys %{$iapps{$cat}}) {
				delete($iapps{$cat}{$name}) if exists $iapps{$dir}{$name};
			}
			}
			delete($iapps{$dir});
			gettag();	# must be </category> else GIGO and we don't care
			next;
		}
		if($tag=~/^(and|or|not)$/i) {	# I think it doesn't make any sense
			warn "How did you get here!?\n";
			my %tmpapps;
			%tmpapps=cand() if $tag=~/^and$/i;
			%tmpapps=cor() if $tag=~/^or$/i;
			%tmpapps=cnot() if $tag=~/^not$/i;
			foreach my $cat (keys %iapps) {
			foreach my $name(keys %{$iapps{$cat}}) {
				delete($iapps{$cat}{$name}) if exists $tmpapps{$cat}{$name};
			}
			}
			next;
		warn "warning: possible XDG file corruption!: $tag\n";
		}
	}
	%iapps;
}

$#menu++;	# let's start from index 1
		# this index is a pointer to menu struct
		# (entry in $menu[] table) via $mno
		# 0 means empty, so it's ommited
		# twill be made choosable

while($trigger==0 || $level>0) {
	$tag=gettag();
	if($tag=~/^menu$/i) {
		$level++;
		$#menu++;
		$menustack[$#menustack+1]=$mno;
		$mno=$#menu;
		$name="";
		$include=0;
		$trigger=1;
		next;
	}
	if($tag=~/^\/menu$/i) {
		#for(my $i=0; $i<=$#menu; $i++) {
		my $i=$menustack[$#menustack];
		if(exists $directory[$level]) {
			foreach my $entry(keys %{$menu[$i]}) {
				delete($menu[$i]{$entry}) if $menu[$i]{$entry}[$ml]==$mno;
			}
			#$name=$directory[$level][$dn];
			#$menu[$i]{$name}[$ml]=$mno;
			#$menu[$i]{$name}[$mi]=$directory[$level][$di];
			$menu[$i]{$directory[$level][$dn]}=[$mno,$directory[$level][$di]];
			delete($directory[$level]);
		}
		#}
		$mno=$i;
		$#menustack--;
		$level--;
		next;
	}
	if($tag=~/^name$/i) {
		$name=getname();
		#$menu[$menustack[$#menustack]]{$name}[$ml]=$mno;
		#$menu[$menustack[$#menustack]]{$name}[$mi]="";
		$menu[$menustack[$#menustack]]{$name}=[$mno,""];
		gettag();	# must be </name> else GIGO and we don't care
		next;
	}
	if($tag=~/^directory$/i) {
		$dir=getname();
		my $lang=0;
		my $name="";
		my $icon="";
		open F_IN, "/usr/share/desktop-directories/$dir" or warn "/usr/share/desktop-directories/$dir: $!\n";
	while(<F_IN>) {
		if (/^Name=(.+)/ && $lang<1) {
			$name=$1;
		}
		if (/^Name\[$lang1\]=(.+)/ && $lang<2) {
			$name=$1;
			$lang=1;
		}
		if (/^Name\[$lang2\]=(.+)/ && $lang<3) {
			$name=$1;
			$lang=2;
		}
		if (/^Name=\[$lang3\](.+)/ && $lang<4) {
			$name=$1;
			$lang=3;
		}
		if (/^Name=\[$lang4\](.+)/ && $lang<5) {
			$name=$1;
			$lang=4;
		}
		$icon=$1 if /^Icon=(.+)/;
	}
	close F_IN;
		if($name ne "") {
			#$directory[$level][$dn]=$name;
			#$directory[$level][$di]=$icon;
			$directory[$level]=[$name,$icon];
		}
		gettag();	# must be </directory> else GIGO and we don't care
		next;
	}
	if($tag=~/^include$/i) {
		$include=1;
		next;
	}
	if($tag=~/^\/include$/i) {
		$include=0;
		next;
	}
	if(($tag=~/^(and|or|not)$/i)&& $include) {
		%tmpapps=cand() if $tag=~/^and$/i;
		%tmpapps=cor() if $tag=~/^or$/i;
		%tmpapps=cnot() if $tag=~/^not$/i;
		foreach my $dir (keys %tmpapps) {
		foreach my $name(keys %{$tmpapps{$dir}}) {
			#$menu[$mno]{$name}[$ml]=-1;
			#$menu[$mno]{$name}[$mi]=$tmpapps{$dir}{$name}[$ai];
			#$menu[$mno]{$name}[$me]=$tmpapps{$dir}{$name}[$ae];
			$menu[$mno]{$name}=[-1,$tmpapps{$dir}{$name}[$ai],$tmpapps{$dir}{$name}[$ae]];
		}
		}
		next;
	}
	if(($tag=~/^category$/i)&& $include) {
		$dir=getname();
		foreach my $name(keys %{$apps{$dir}}) {
			#$menu[$mno]{$name}[$ml]=-1;
			#$menu[$mno]{$name}[$mi]=$apps{$dir}{$name}[$ai];
			#$menu[$mno]{$name}[$me]=$apps{$dir}{$name}[$ae];
			$menu[$mno]{$name}=[-1,$apps{$dir}{$name}[$ai],$apps{$dir}{$name}[$ae]];
		}
		gettag();	# must be </category> else GIGO and we don't care
		next;
	}
	if($tag=~/^mergefile$/i) {
		$name=getname();
		gettag();	# must be </mergefile> else GIGO and we don't care
		my $tmpfile="";
		open F_IN, "/etc/xdg/menus/$name" or warn "/etc/xdg/menus/$name: $!\n";
		while(<F_IN>) {
			chop;
			$tmpfile.=$_;
		}
		close F_IN;
		$file=$tmpfile.$file;
		next;
	}
	if(($tag=~/^\/(name|directory|and|or|not|category|mergefile)$/i)&& $include) {
		warn "warning: XDG file corrupted!\n";
	}
	warn "Omitted tag: $tag\n" if $o_tags;
}

warn "Omitted ending: $file\n" if(($file ne "")&& $o_end);

$level=-1;
sub outgen {
	my $no=$_[0];
	foreach my $entry(sort keys %{$menu[$no]}) {
		#next if $menu[$no]{$entry}[$ml]==0;
		for(my $i=0; $i<=$level; $i++) {
			print "	";
		}
		if($menu[$no]{$entry}[$ml]<0) {
			print "Entry: \"$entry\" \"$menu[$no]{$entry}[$mi]\" $menu[$no]{$entry}[$me]\n";
		} else {
			print "Menu: \"$entry\" \"$menu[$no]{$entry}[$mi]\"\n";
			$level++;
			outgen($menu[$no]{$entry}[$ml]);
			$level--;
		}
	}
}

outgen(0);
